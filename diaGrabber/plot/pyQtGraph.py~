# -*- coding: utf-8 *-*
#import numpy as np
#from copy import deepcopy
import sys
import numpy as np
#import scipy

from diaGrabber import  _utils
from ._plot import _plot

from pyqtgraph.Qt import QtGui, QtCore
import numpy as np
import pyqtgraph as pg
import pyqtgraph.dockarea as pgDock
import pyqtgraph.parametertree.parameterTypes as pTypes
from pyqtgraph.parametertree import Parameter, ParameterTree, ParameterItem, registerParameterType



class interactive(object):

	def __init__(self):


		self.hasInteractiveModus = True



	def plot(self, matrixClass, **kwargs):
		'''
		For all possible kwargs look at **setArgs()**
		'''
		self.matrixClass = matrixClass
		self.basisMatrix = self.matrixClass.basisMatrix
		self.mergeMatrix = self.matrixClass.mergeMatrix
		self._merge_dim = self.matrixClass._merge_dim
		self._basis_dim = self.matrixClass._basis_dim
		self.nBasis = self.matrixClass.nBasis
		self.nMerge = self.matrixClass.nMerge
		#standard
		self.show_merge = range(self.nMerge)#show all merge-dim
		self.show_basis = range(self.nBasis)#show all basis-dim
		self.interactive = False

		self._setFPS(20)
		self.limitReadoutRate = False
		self._setLPS(1)
		#self.fps = 20
		#self.lps = 1
		self.windowSize = [1000,600]
		self.enableAutoRange = []
		self.showType = "together"
		self._setColorTheme("default")
		self.build_preferences_dock = True
		self.end_readOut = False

		self.setArgs(True, **kwargs)





		##create qt-window
		app = QtGui.QApplication([])
		self.win = QtGui.QMainWindow()
		#win = pg.GraphicsWindow(title="Interactive Plot")
		self.win.resize(self.windowSize[0],self.windowSize[1])

		self.createPlots()

				
			#else:
			#	sys.exit(NotImplemented)
				



		self.win.show()
		
		

		
		def updateValues():
			#lineWise updating data
			done_readOut = self.matrixClass._fill(True, self.end_readOut)
			if done_readOut or done_readOut == None: #done_readOut = None, if the readoutprocess doesnt func
				 app.quit()#close the window

#######################################
		#def getMergeExtract():
			#[e for i, e in enumerate(main_list) if i in indexes]

		class mergeExtract:
			
			def __init__(self):
			#...hier bestimmen, welche methode genutzt werden soll
				pass
			def get(self):
				#merge_extract = self.mergeMatrix[m][:,0][self._basis_dim[show_basis[0]]._plot_range]
				pass
		#array([[  1.,  nan,  nan],
       #[ nan,   5.,  nan],
       #[  7.,  nan,  nan]])
			#	np.nansum(a,1)
#array([ 1.,  5.,  7.])


		def updatePlot():
			##########################################
			if self.nBasis == 1:
				basis_extract = self.basisMatrix[self.show_basis[0]][self._basis_dim[self.show_basis[0]]._plot_range]
				for n,m in enumerate(self.show_merge):
					#print self.mergeMatrix[m].shape,88
					merge_extract = self.mergeMatrix[m][self._basis_dim[self.show_basis[0]]._plot_range]
					for b in range(len(self._basis_dim)):
						#basis dim not to plot -- besser formulieren
						if b != self.show_basis[0] and b not in self.show_basis:
							merge_extract = np.nansum(merge_extract,b)
					#print merge_extract.shape
					#print merge_extract
					#from copy import deepcopy
					#merge_extract2=deepcopy(merge_extract)
					#print basis_extract.shape
					self.curves[n].setData(basis_extract, merge_extract)
				for p in self.plots:
					if "x" in self.enableAutoRange:
						p.setXRange(self._basis_dim[self.show_basis[0]]._include_from_to[0],
							self._basis_dim[self.show_basis[0]]._include_from_to[1])
					if "y" in self.enableAutoRange:
					##get min, max values for all merge-dims
					#miny = self._merge_dim[0]._include_from_to[0]
					#maxy = self._merge_dim[0]._include_from_to[1]
					#for i in range(1,self.nMerge):
						#if self._merge_dim[i]._include_from_to[0] < miny:
							#miny = self._merge_dim[i]._include_from_to[0]
						#if self._merge_dim[i]._include_from_to[1] > maxy:
							#maxy = self._merge_dim[i]._include_from_to[1]
					#print miny,maxy
					#self.plot.setYRange(miny,maxy)
						p.enableAutoRange('y', True)
				
			elif self.nBasis == 2:
				for n,m in enumerate(self.show_merge):
				#sys.exit("mehrere merge noch nicht drinne fÃ¼r image")
					merge_extract = self.mergeMatrix[m][self._basis_dim[0]._plot_range][self._basis_dim[1]._plot_range]

					self.plots[n].setImage(_utils.nanToZeros(merge_extract),
						autoRange=False)
			else:
				sys.exit(NotImplemented)



		if self.interactive:

			#set timer
			self.timerLPS = QtCore.QTimer()
			#get new basis-merge-values
			self.timerLPS.timeout.connect(updateValues)
			self.timerLPS.start(self.wait_ms_lps)
			self.timerFPS = QtCore.QTimer()
			self.timerFPS.timeout.connect(updatePlot)
			self.timerFPS.start(self.wait_ms)



		if (sys.flags.interactive != 1) or not hasattr(QtCore, 'PYQT_VERSION'):
			QtGui.QApplication.instance().exec_()




	def createPlots(self):

		self.area = pgDock.DockArea()
		self.win.setCentralWidget(self.area)
		self.docks = []


		self.plot_size_x = int(self.windowSize[0]*0.7)#int(windowSize[0]*(2/3))

		if self.showType == "together":
			self.docks.append(pgDock.Dock("together", size=(self.plot_size_x, 1)))
			self.area.addDock(self.docks[-1])
		
		elif self.showType == "widged":
			for m in range(self.nMerge):
				self.docks.append(pgDock.Dock("widget %s" %m, size=(self.plot_size_x, 1)))
			#for m in range(self.nMerge):
				self.area.addDock(self.docks[-1])
		else:
			sys.exit("ERROR: showType invalid")

		
		

		#if self.nBasis > 1:
			##set axis name and range
			##=========
			#yAxis = pg.AxisItem("left")##y
			##yScale = self._basis_dim[1].resolution/self._basis_dim[1]
			##yAxis.setScale(0.001)
			#yAxis.setLabel(units = self._basis_dim[1].name)
			#xAxis = pg.AxisItem("bottom")##y
			#xAxis.setLabel(units = self._basis_dim[0].name)
			##yAxis.setRange(self._basis_dim[1].include_from_to[1],self._basis_dim[1].include_from_to[0])
			##self.plot = pg.ImageView(view=pg.PlotItem(title="testtest", axisItems = {"left": yAxis, "bottom": xAxis}))
			##self.plot = win.addItem(pg.ImageView())
			#self.plot = pg.ImageView()
			##self.plot = win.addViewBox(lockAspect=True)
			##self.img = pg.ImageItem()
			##self.plot.addItem(self.img)
			##self.plot.autoRange()
			
		#simple 2d-plot - no imag
		yAxis = []#pg.AxisItem("left")##y
		xAxis = []#pg.AxisItem("bottom")##y
		#xAxis.setLabel(units = self._basis_dim[0].name)
		self.plots = []
		self.curves = []
		colorList = ['r', 'g', 'b', 'c', 'm', 'y', 'k', 'w']

		if self.showType == "together":
			yAxis.append(pg.AxisItem("left"))##y
			xAxis.append(pg.AxisItem("bottom"))##y
			if self.nBasis == 1:
				xAxis[-1].setLabel(units = self._basis_dim[0].name)

				self.plots.append(pg.PlotWidget(axisItems = {"left": yAxis[0], "bottom": xAxis[0]}))
				self.plots[-1].setXRange(self._basis_dim[0]._include_from_to[0],self._basis_dim[0]._include_from_to[1])
			else:
				sys.exit("ERROR: plotting multible images together isnt impl. at the moment")

			docks[0].addWidget(self.plots[0])

			#self.plot = win.addPlot(title="Updating plot", axisItems = {"left": yAxis, "bottom": xAxis})
			self.plots[0].enableAutoRange('xy', False)
		
			if self.nMerge > 1:#if there are more plots draw a legend
				self.plots[0].addLegend()
			else:
				yAxis[0].setLabel(units = self._merge_dim[0].name)

		#create all plots and ink in range of the colorlist
			for i in self.show_merge:
				self.curves.append(self.plots[0].plot(pen=colorList[i%len(colorList)], symbol='+', name=self._merge_dim[i].name))

		elif self.showType == "widged":
			for n,m in enumerate(self.show_merge):
				yAxis.append(pg.AxisItem("left"))##y
				xAxis.append(pg.AxisItem("bottom"))##y
				if self.nBasis == 1:
					#labelStyle = {'color': self.label_color}
	
					xAxis[-1].setLabel(units = self._basis_dim[self.show_basis[0]].name)
	
					self.plots.append(pg.PlotWidget(axisItems = {"left": yAxis[-1], "bottom": xAxis[-1]}))
					
					self.plots[-1].enableAutoRange('xy', False)
					yAxis[-1].setLabel(units = self._merge_dim[m].name)
					self.curves.append(self.plots[-1].plot(pen=colorList[n%len(colorList)], symbol='+', name=self._merge_dim[m].name))
	
					
					#self.plots[-1].setBackground(self.bg_color)
					
					self.plots[-1].setXRange(self._basis_dim[self.show_basis[0]]._include_from_to[self.show_basis[0]],self._basis_dim[self.show_basis[0]]._include_from_to[1])
			
				elif self.nBasis == 2:
					
					#xAxis[-1].setScale(scale=self._basis_dim[0]._include_from_to[1]-self._basis_dim[0]._include_from_to[0]/self._basis_dim[0].resolution)
					xAxis[-1].setLabel(units = self._basis_dim[0].name)
					#yAxis[-1].setTicks(self.basisMatrix[1])
					yAxis[-1].setLabel(units = self._basis_dim[1].name)

					self.plots.append(pg.ImageView(view=pg.PlotItem(title=self._merge_dim[m].name,
						axisItems = {"left": yAxis[-1], "bottom": xAxis[-1]})))
					#self.plots[-1].setBackground("w")
					#self.plots.append(pg.ImageView(view=pg.PlotItem(title="testtest", axisItems = {"left": yAxis[-1], "bottom": xAxis[-1]})))
					#self.curves.append(pg.ImageItem())
					#self.plots[-1].setImage(self.curves[-1])
					
				else:
					sys.exit(NotImplemented)
					
				self.docks[n].addWidget(self.plots[-1])
		
		
		if self.build_preferences_dock:
			self.buildPreferencesDock()
		
	def setArgs(self, runningFirstTime, **kwargs):
		'''
		Optional kwargs ("keyword arguments") are:

		==================     ========  =======          ============================
		Keyword	               Type      Default          Description
		==================     ========  =======          ============================
		*interactive*          bool      False            [True, False]
		*merge*	               list      [All merge-dims] instances of mergeDimension of the source
		*basis*	               list      [All basis-dims] instances of basisDimension of the source
		*fps*                  float     20               frames per seconds
		*lps*                  float     None              readout n lines from source per second (needs limitReadoutRate = True)
		*limitReadoutRate*     bool      False            Choose whether to limit the readoutrate via arg *lps*
		*enableAutoRange*      list      []               ["x", "y"]
		*showType*             string    "together"       ["together", "widget"]
		*colorTheme*           string    "default"        ["default", "bright"]
		*windowSize*           list      [1000,600]       [size_x, size_y] e.g. **[1000,600]**
		*showPreferences*      bool      True             [True, False]
		==================     ========  =======          ============================
		'''

		#individual
		for key in kwargs:
			if key == "interactive":
				self.interactive = bool(kwargs[key])
			elif key == "merge":
				self.show_merge = []
				for merge in kwargs[key]:
					##proove for mergeDim fehlt
					self.show_merge.append(merge._mergeIndex)
				self.nMerge = len(self.show_merge)
			elif key == "basis":
				self.show_basis = []
				for basis in kwargs[key]:
					##proove for mergeDim fehlt
					self.show_basis.append(basis._basisIndex)
				self.nBasis = len(self.show_basis)
			elif key == "fps" and kwargs[key] != self.fps:
					self._setFPS(kwargs[key])
					#fps_changed = True
					#fps = kwargs[key]
			elif key == "lps" and (kwargs[key] != self.lps or not self.limitReadoutRate):
					#lps_changed = True
					#self.lps = kwargs[key]
					self.limitReadoutRate = True
					self._setLPS(kwargs[key])
			elif key == "limitReadoutRate":
					self.limitReadoutRate = bool(kwargs[key])
					
			elif key == "enableAutoRange":
				self.enableAutoRange = kwargs[key]
			elif key == "showType":
				self.showType = kwargs[key]
			elif key == "colorTheme" and kwargs[key] != self.colorTheme:
				#colorTheme_changed = True
				#self.colorTheme = kwargs[key]
				self._setColorTheme(kwargs[key])
			elif key == "windowSize":
				self.windowSize = list( int(kwargs[key][0]), int(kwargs[key][1]) )
			elif key == "showPreferences":
				self.build_preferences_dock = bool(kwargs[key])

		#if runningFirstTime or fps_changed:
		#	self._setFPS()
		#if runningFirstTime or lps_changed:
		#	self._setLPS()
		#if runningFirstTime or colorTheme_changed:
		#	self._setColorTheme()


	def _setFPS(self, fps):
		self.fps = float(fps)
		self.wait_ms = 1000/self.fps #frames per second
		try:
			self.timerFPS.setInterval(self.wait_ms)
		except AttributeError:#if timer is not defined yet
			pass
	def _setLPS(self, lps):
		self.lps = float(lps)
		if self.lps <= 0:
			print "Set readout lines per second to 1e-5"
			self.lps = 1e-5
		if self.limitReadoutRate:
			self.wait_ms_lps = 1000/self.lps #lines per second
		else:
			self.wait_ms_lps = 0
		try:
			self.timerLPS.setInterval(self.wait_ms_lps)
		except AttributeError:#if timer is not defined yet
			pass
		
	def _setColorTheme(self, colorTheme):
		'''choose the colortheme for the plot-output, possible values are:
				* "default"
				* "bright"
		'''
		self.colorTheme = colorTheme

		if self.colorTheme == "default" or self.colorTheme == "":
			self.ticks_color = (200,200,200)
			self.label_color = '#fff'
			self.bg_color = (0,0,0)
			
		elif self.colorTheme == "bright":
			self.ticks_color = (30,30,30)
			self.label_color = '#000'
			self.bg_color = 'w'
		pg.setConfigOption('background', self.bg_color)
		pg.setConfigOption('foreground', self.label_color)



	def buildPreferencesDock(self):

		params = [
			plotBasisDims(self, name='Plot basis-dimensions'),
			plotMergeDims(self, name='Plot merge-dimensions'),
			readoutPlotRates(self, name='Readout/Plot-Rates'),


			{'name': 'Save/Restore widget-layout', 'type': 'group', 'children': [
				{'name': 'Save', 'type': 'action', 'children': [
					{'name': 'Save to file', 'type': 'bool', 'value': True},
					{'name': 'Filename', 'type': 'str', 'value': 'preferences/my_widget_layout'},
				]},
				{'name': 'Restore', 'type': 'action', 'children': [
					{'name': 'Restore from file', 'type': 'bool', 'value': False},
					{'name': 'Filename', 'type': 'str', 'value': 'preferences/my_widget_layout'},
				]},
			]},

			{'name': 'Save/Restore preferences', 'type': 'group', 'children': [
				{'name': 'Save', 'type': 'action'},
				{'name': 'Restore', 'type': 'action', 'children': [
					{'name': 'Add missing items', 'type': 'bool', 'value': True},
					{'name': 'Remove extra items', 'type': 'bool', 'value': True},
				]},
			]},
		]
		
		## Create tree of Parameter objects
		p = Parameter.create(name='params', type='group', children=params)
		


		## If anything changes in the tree, print a message
		def printChange(param, changes):
			print("tree changes:")
			for param, change, data in changes:
				path = p.childPath(param)
				if path is not None:
					childName = '.'.join(path)
				else:
					childName = param.name()
				print('  parameter: %s'% childName)
				print('  change:	%s'% change)
				print('  data:	  %s'% str(data))
				print('  ----------')
		p.sigTreeStateChanged.connect(printChange)

		##SAVE PREFERENCES

		def savePreferences():
			#global statePreferences
			self.statePreferences = p.saveState()
		def restorePreferences():
			#global statePreferences
			add = p['Save/Restore preferences', 'Restore', 'Add missing items']
			rem = p['Save/Restore preferences', 'Restore', 'Remove extra items']
			p.restoreState(self.statePreferences, addChildren=add, removeChildren=rem)
		p.param('Save/Restore preferences', 'Save').sigActivated.connect(savePreferences)
		p.param('Save/Restore preferences', 'Restore').sigActivated.connect(restorePreferences)


		##SAVE WIDGET

		def saveWidgetLayout():
			#global stateWidgetLayout
			self.stateWidgetLayout = self.area.saveState()
			if p['Save/Restore widget-layout', 'Save', 'Save to file']:
				#write state to file
				filename = p['Save/Restore widget-layout', 'Save', 'Filename']
				_utils.prepareFileSystem(filename)
				saveWidgetFile = open(filename, "w")
				saveWidgetFile.write(str(self.stateWidgetLayout))
				saveWidgetFile.close()


		def restoreWidgetLayout():
			#global stateWidgetLayout
			if p['Save/Restore widget-layout', 'Restore', 'Restore from file']:
				filename = p['Save/Restore widget-layout', 'Restore', 'Filename']
				self.stateWidgetLayout = saveWidgetFile = eval(open(filename, "r").read())

				
			self.area.restoreState(self.stateWidgetLayout)
		p.param('Save/Restore widget-layout', 'Save').sigActivated.connect(saveWidgetLayout)
		p.param('Save/Restore widget-layout', 'Restore').sigActivated.connect(restoreWidgetLayout)

		## Create  ParameterTree widget,
		t = ParameterTree()
		t.setParameters(p, showTop=False)
		
		#t.show() #only nec. when allone
		#t.resize(400,800)
		
		#create new dock
		preferences_size = int(self.windowSize[0] - self.plot_size_x)
		self.docks.append( pgDock.Dock("Preferences", size=(preferences_size, 1)) )
		#append parameterTree-instance to dock
		self.docks[-1].addWidget(t)
		# add dock to area
		self.area.addDock(self.docks[-1], 'left')


			#autosave
		self.statePreferences = p.saveState()
			#autosave
		self.stateWidgetLayout = self.area.saveState()


class plotBasisDims(pTypes.GroupParameter):
	
	def __init__(self,parentC,**opts):#
		self.parentC = parentC

		opts['type'] = 'bool'
		opts['value'] = True
		pTypes.GroupParameter.__init__(self, **opts)
		self.basis_opt = []
		for n,b in enumerate(self.parentC._basis_dim):
			plot_basis = b._basisIndex in self.parentC.show_basis
			self.basis_opt.append(self.addChild({'name': b.name, 'type': 'bool', 'value': plot_basis}))
			#self.plot_range.append(0)
			if plot_basis:
				self.addPlotRange(n,b)
			else:
				self.addConcentrateOpt(n,b)
			self.param(b.name).sigValueChanged.connect(self.changePlotStatus)
		self.plot_types = self.addChild({'name': 'Available Plot-Types', 'type': 'group'})
		self.setAvailablePlotTypes()

	def addPlotRange(self,n,b):
		self.basis_opt[n].addChild({'name': 'Plot-Range', 'type': 'group', 'children': [
			{'name': 'from', 'type': 'int', 'value': 0, 'limits': (0, b.resolution-1)},
			{'name': 'to', 'type': 'int', 'value':b.resolution, 'limits': (1, b.resolution-1)},
			{'name': 'step', 'type': 'int', 'value': 1, 'limits': (1, b.resolution-1)},
			]})

	def changePlotStatus(self):
		for n,b in enumerate(self.parentC._basis_dim):
			#remove all children
			self.basis_opt[n].clearChildren()
			if self.param(b.name).value():
				self.addPlotRange(n,b)
				if n not in self.parentC.show_basis:
					self.parentC.show_basis.append(n)
			else:
				self.addConcentrateOpt(n,b)
				if n in self.parentC.show_basis:
					self.parentC.show_basis.pop(self.parentC.show_basis.index(n))
			self.setAvailablePlotTypes()
		self.parentC.nBasis = len(self.parentC.show_basis)
		self.parentC.createPlots()
	
	def setAvailablePlotTypes(self):
		self.plot_types.clearChildren()
		#print len(self.parentC.show_basis),9999999999999999, self.parentC.show_basis
		#sys.exit()
		#2d-plot
		if self.parentC.nBasis == 0:
			self.plot_types.addC
			
			
			hild({'name': 'Nothing', 'type': 'bool', 'value': True})
			#sys.exit()
		elif self.parentC.nBasis == 1:
			self.plot_types.addChild({'name': '2D-Plot', 'type': 'bool', 'value': True})
		elif self.parentC.nBasis == 2:
			self.plot_types.addChild({'name': '3D-Plot', 'type': 'bool', 'value': True})
			self.plot_types.addChild({'name': 'Image', 'type': 'bool', 'value': False})

		
	def addConcentrateOpt(self,n,b):
		self.basis_opt[n].addChild({'name': 'Concentrate-Basis', 'type': 'group', 'children': [
			{'name': 'sum', 'type': 'bool', 'value': True},
			{'name': 'mean', 'type': 'bool', 'value':False},
			{'name': 'at position', 'type': 'int', 'value': -1, 'limits': (-1, b.resolution-1)},
			{'name': 'value', 'type': 'float', 'value': 0, 'readonly': True},
			]})
			
		self.param(b.name, 'Concentrate-Basis','at position').sigValueChanged.connect(self.calcValueFromPosition)
		self.param(b.name, 'Concentrate-Basis','sum').sigValueChanged.connect(self.concentrateViaSum)
		self.param(b.name, 'Concentrate-Basis','mean').sigValueChanged.connect(self.concentrateViaMean)

	def concentrateViaSum(self):
		for n,b in enumerate(self.parentC._basis_dim):
			if self.param(b.name, 'Concentrate-Basis','sum').value() == True:
				###call extract-klasse-init
				self.param(b.name, 'Concentrate-Basis', 'mean').setValue(False, blockSignal=self.concentrateViaMean)
			else:
				self.param(b.name, 'Concentrate-Basis', 'mean').setValue(True, blockSignal=self.concentrateViaMean)
	
	def concentrateViaMean(self):
		for n,b in enumerate(self.parentC._basis_dim):
			if self.param(b.name, 'Concentrate-Basis','mean').value() == True:
				###call extract-klasse-init
				self.param(b.name, 'Concentrate-Basis', 'sum').setValue(False, blockSignal=self.concentrateViaSum)
			else:
				self.param(b.name, 'Concentrate-Basis', 'sum').setValue(True, blockSignal=self.concentrateViaSum)

	def calcValueFromPosition(self):
		for n,b in enumerate(self.parentC._basis_dim):
			if not self.param(b.name, 'Concentrate-Basis','at position').valueIsDefault():
				position = self.param(b.name, 'Concentrate-Basis','at position').value()
				self.param(b.name, 'Concentrate-Basis', 'value').setValue(self.parentC.basisMatrix[n][position])


class plotMergeDims(pTypes.GroupParameter):
	
	def __init__(self,parentC,**opts):#
		#self.parentC = parentC

		opts['type'] = 'bool'
		opts['value'] = True
		pTypes.GroupParameter.__init__(self, **opts)
		#self.merge_opt = []
		#mergeTogether(name='Together')
		self.addChild(mergeTogether(parentC, name='Together'))
		self.addChild(mergeSeparated(parentC, name='Separated'))
		
		


class mergeTogether(pTypes.GroupParameter):
	def __init__(self, parentC, **opts):
		self.parentC = parentC
		
		opts['type'] = 'group'
		opts['addText'] = "Add"
		#opts['addList'] = self.parentC.show_merge
		opts['addList'] = ['str', 'float', 'int']
		pTypes.GroupParameter.__init__(self, **opts)
	
	def addNew(self, typ):
		val = {
			'str': '',
			'float': 0.0,
			'int': 0
		}[typ]
		self.addChild(dict(name="ScalableParam %d" % (len(self.childs)+1), type=typ, value=val, removable=True, renamable=True))

		##############################
		self.setAddList(["12","22","3"])
		##############################

class mergeSeparated(pTypes.GroupParameter):
	def __init__(self, parentC, **opts):
		self.parentC = parentC

		opts['type'] = 'group'
		opts['addText'] = "Add"
		opts['addList'] = ['str', 'float', 'int']
		pTypes.GroupParameter.__init__(self, **opts)
	
	def addNew(self, typ):
		val = {
			'str': '',
			'float': 0.0,
			'int': 0
		}[typ]
		self.addChild(dict(name="ScalableParam %d" % (len(self.childs)+1), type=typ, value=val, removable=True, renamable=True))
		

class readoutPlotRates(pTypes.GroupParameter):
	
	def __init__(self,parentC,**opts):#
		#self.parentC = parentC
		self.parentC = parentC
		
		opts['type'] = 'bool'
		opts['value'] = True
		pTypes.GroupParameter.__init__(self, **opts)
		#self.merge_opt = []
		#mergeTogether(name='Together')
		self.paramFPS = self.addChild(
			{'name': 'Plot frames per second', 'type': 'int', 'value': self.parentC.fps, 'limits': (1, 200)})
		self.paramLimitLPS = self.addChild(
			{'name': 'Limit readout-rate', 'type': 'bool', 'value': self.parentC.limitReadoutRate}
			)
		self.changeLimitReadoutRate()
		
		self.paramFPS.sigValueChanged.connect(self.changeFPS)
		self.paramLimitLPS.sigValueChanged.connect(self.changeLimitReadoutRate)
	
	def changeFPS(self):
		self.parentC._setFPS(self.paramFPS.value())
	
	def changeLimitReadoutRate(self):
		self.parentC.limitReadoutRate = self.paramLimitLPS.value()
		if self.paramLimitLPS.value():
			
			self.paramLPS = self.paramLimitLPS.addChild({'name': 'lines per second', 'type': 'int', 'value': self.parentC.lps, 'limits': (1, 100000)})
			self.paramLPS.sigValueChanged.connect(self.changeLPS)
			self.changeLPS()
		else:
			self.changeLPS()
			self.paramLimitLPS.removeChild(self.paramLPS)
			
	def changeLPS(self):
		try:
			self.parentC._setLPS(self.paramLPS.value())
		except AttributeError:#paramLPS not defined jet
			self.parentC._setLPS(0)
